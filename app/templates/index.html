<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Bot pour Qwanteos</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <style>
        /* Styles généraux pour le corps de la page et la mise en page Flexbox */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex; /* Utilise Flexbox pour organiser la barre latérale et le contenu principal */
            height: 100vh; /* S'assure que le corps prend toute la hauteur de la fenêtre du navigateur */
            overflow: hidden; /* Empêche le défilement global du body, car le défilement sera géré par les sous-conteneurs */
        }

        /* Styles pour la barre latérale gauche (menu des conversations) */
        #sidebar {
            width: 250px; /* Largeur fixe de la barre latérale */
            min-width: 200px; /* Largeur minimale si la fenêtre est redimensionnée */
            background-color: #333; /* Fond sombre */
            color: white; /* Texte blanc */
            padding: 20px;
            box-sizing: border-box; /* Inclut le padding dans la largeur */
            height: 100%; /* Occupe toute la hauteur disponible */
            overflow-y: auto; /* Permet le défilement vertical si le contenu du menu est long */
            flex-shrink: 0; /* Empêche la barre latérale de se rétrécir lorsque le contenu principal a besoin de plus d'espace */
        }
        #sidebar h2 { margin-top: 0; color: #4CAF50; } /* Titre du menu */
        #conversation-menu ul { list-style: none; padding: 0; } /* Liste des conversations */
        #conversation-menu li { margin-bottom: 10px; }
        #conversation-menu button {
            width: 100%; padding: 10px; background-color: #555; color: white; border: none; border-radius: 5px;
            cursor: pointer; text-align: left; font-size: 1em; display: flex; justify-content: space-between; align-items: center;
        }
        #conversation-menu button:hover { background-color: #777; } /* Effet au survol */
        #conversation-menu button.active { background-color: #4CAF50; } /* Bouton de conversation active */
        .delete-btn { /* Bouton de suppression d'une conversation */
            background-color: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;
            font-size: 0.8em; padding: 3px 6px; margin-left: 10px;
        }
        .delete-btn:hover { background-color: #d32f2f; }
        #new-conv-btn, #ephemeral-conv-btn { /* Boutons "Nouvelle" et "Éphémère" */
            background-color: #007bff; margin-top: 15px;
        }
        #new-conv-btn:hover, #ephemeral-conv-btn:hover { background-color: #0056b3; }

        /* Styles pour le contenu principal (zone de chat et zone de saisie) */
        #main-content {
            flex-grow: 1; /* Occupe tout l'espace horizontal restant */
            display: flex; /* Utilise Flexbox pour organiser les éléments verticalement */
            flex-direction: column;
            height: 100%; /* Occupe toute la hauteur disponible */
        }
        #chat-box {
            flex-grow: 1; /* La boîte de chat prend tout l'espace vertical disponible */
            padding: 20px;
            overflow-y: auto; /* Permet le défilement vertical du contenu du chat */
            background-color: #fff;
            border-bottom: 1px solid #ddd;
        }
        /* Styles pour les messages individuels dans le chat */
        .message { margin-bottom: 15px; padding: 10px; border-radius: 8px; max-width: 80%; }
        .user-message { /* Messages de l'utilisateur */
            background-color: #e1ffc7; align-self: flex-end; margin-left: auto; /* Aligné à droite */
        }
        .bot-message { /* Messages du bot */
            background-color: #f1f0f0; align-self: flex-start; /* Aligné à gauche */
        }
        
        /* Pas de styles spécifiques pour le code Markdown si les bibliothèques ne sont pas incluses */
        /* .message p:last-child { margin-bottom: 0; } */
        /* .message pre { ... } */
        /* .message code { ... } */
        /* .message pre code { ... } */

        /* Styles pour la zone de saisie du message */
        #input-area { display: flex; padding: 20px; background-color: #eee; border-top: 1px solid #ddd; }
        #user-input { flex-grow: 1; padding: 10px; border: 1px solid #ccc; border-radius: 5px; margin-right: 10px; }
        #send-button { padding: 10px 20px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #send-button:hover { background-color: #45a049; }
        #loading-indicator { display: none; text-align: center; padding: 10px; color: #888; } /* Indicateur de chargement */
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>Conversations</h2>
        <div id="conversation-menu">
            <button id="ephemeral-conv-btn">Nouvelle Conversation Éphémère</button>
            <button id="new-conv-btn">Créer Nouvelle Conversation</button>
            <ul id="conversation-list">
                </ul>
        </div>
    </div>
    
    <div id="main-content">
        <div id="chat-box">
            </div>
        <div id="loading-indicator">Chargement...</div>
        <div id="input-area">
            <input type="text" id="user-input" placeholder="Tapez votre message...">
            <button id="send-button">Envoyer</button>
        </div>
    </div>

    <script>
        let currentConversationId = "new_ephemeral"; // ID de la conversation active ("new_ephemeral" pour éphémère)
        let ephemeralChatHistory = []; // Historique de la conversation éphémère (stocké côté client)

        // Récupération des éléments du DOM
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const conversationList = document.getElementById('conversation-list');
        const newConvBtn = document.getElementById('new-conv-btn');
        const ephemeralConvBtn = document.getElementById('ephemeral-conv-btn');

        // Fonction pour afficher un message dans la boîte de chat
        function displayMessage(sender, content) { // Plus de paramètre isStreaming
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');
            messageDiv.textContent = content; // Affichage direct du texte
            chatBox.appendChild(messageDiv);
            chatBox.scrollTop = chatBox.scrollHeight; // Fait défiler la boîte de chat vers le bas

            // Met à jour l'historique éphémère si la conversation active est éphémère
            if (currentConversationId === "new_ephemeral") {
                ephemeralChatHistory.push({ sender: sender, content: content });
            }
        }

        // Charge et affiche les messages d'une conversation spécifique (persistante ou éphémère)
        async function loadConversation(convId) {
            currentConversationId = convId;
            chatBox.innerHTML = ''; // Vide la boîte de chat actuelle
            
            // Met à jour l'état visuel du bouton de conversation actif dans la barre latérale
            document.querySelectorAll('#conversation-list button').forEach(btn => btn.classList.remove('active'));
            ephemeralConvBtn.classList.remove('active');
            if (convId === "new_ephemeral") {
                ephemeralConvBtn.classList.add('active');
                ephemeralChatHistory = []; // Réinitialise l'historique éphémère lors de la sélection
            } else {
                const activeBtn = document.querySelector(`#conversation-list button[data-id="${convId}"]`);
                if (activeBtn) activeBtn.classList.add('active');
            }

            if (convId !== "new_ephemeral") {
                // Pour les conversations persistantes, charge les messages depuis le backend
                loadingIndicator.style.display = 'block';
                try {
                    const response = await fetch(`/conversations/${convId}`);
                    const messages = await response.json();
                    messages.forEach(msg => displayMessage(msg.sender, msg.content));
                } catch (error) {
                    console.error('Erreur lors du chargement de la conversation:', error);
                    displayMessage('bot', 'Erreur lors du chargement de cette conversation.');
                } finally {
                    loadingIndicator.style.display = 'none';
                }
            } else {
                // Pour les conversations éphémères, re-affiche l'historique stocké côté client
                ephemeralChatHistory.forEach(msg => displayMessage(msg.sender, msg.content));
            }
        }

        // Récupère et affiche la liste des conversations persistantes depuis le backend
        async function fetchConversations() {
            try {
                const response = await fetch('/conversations');
                const conversations = await response.json();
                conversationList.innerHTML = ''; // Vide la liste actuelle
                // Ajoute chaque conversation à la liste dans la barre latérale
                conversations.forEach(conv => {
                    const li = document.createElement('li');
                    const button = document.createElement('button');
                    button.textContent = conv.name;
                    button.dataset.id = conv.id;
                    button.onclick = () => loadConversation(conv.id); // Charge la conversation au clic

                    const deleteBtn = document.createElement('button');
                    deleteBtn.classList.add('delete-btn');
                    deleteBtn.textContent = 'X';
                    deleteBtn.onclick = async (e) => { // Gère la suppression d'une conversation
                        e.stopPropagation(); // Empêche le clic de se propager au bouton parent
                        if (confirm(`Voulez-vous vraiment supprimer la conversation "${conv.name}" ?`)) {
                            await deleteConversation(conv.id);
                        }
                    };
                    button.appendChild(deleteBtn);
                    li.appendChild(button);
                    conversationList.appendChild(li);
                });
            } catch (error) {
                console.error('Erreur lors du chargement des conversations:', error);
            }
        }

        // Gère la création d'une nouvelle conversation persistante
        newConvBtn.onclick = async () => {
            const convName = prompt('Nom de la nouvelle conversation (max 3 conversations persistantes) :');
            if (convName) {
                try {
                    const response = await fetch('/conversations', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: convName })
                    });
                    const data = await response.json();
                    if (response.ok) {
                        await fetchConversations(); // Met à jour la liste des conversations
                        loadConversation(data.id); // Charge la nouvelle conversation
                        displayMessage('bot', `Conversation "${convName}" créée et activée.`);
                    } else {
                        alert('Erreur: ' + (data.error || 'Impossible de créer la conversation.'));
                    }
                } catch (error) {
                    console.error('Erreur lors de la création de la conversation:', error);
                    alert('Erreur de connexion lors de la création de la conversation.');
                }
            }
        };

        // Gère le basculement vers une nouvelle conversation éphémère
        ephemeralConvBtn.onclick = () => {
            loadConversation("new_ephemeral");
            displayMessage('bot', 'Nouvelle conversation éphémère activée.');
        };

        // Gère la suppression d'une conversation persistante
        async function deleteConversation(convId) {
            try {
                const response = await fetch(`/conversations/${convId}`, { method: 'DELETE' });
                if (response.ok) {
                    await fetchConversations(); // Met à jour la liste des conversations
                    if (currentConversationId === convId) {
                        loadConversation("new_ephemeral"); // Bascule vers l'éphémère si la conversation active est supprimée
                        displayMessage('bot', 'Conversation supprimée. Basculement vers conversation éphémère.');
                    } else {
                        displayMessage('bot', 'Conversation supprimée.');
                    }
                } else {
                    const data = await response.json();
                    alert('Erreur lors de la suppression: ' + (data.error || 'Inconnu.'));
                }
            } catch (error) {
                    console.error('Erreur lors de la suppression de la conversation:', error);
                    alert('Erreur de connexion lors de la suppression.');
            }
        }

        // Gère l'envoi du message de l'utilisateur au backend
        sendButton.onclick = async () => {
            const message = userInput.value.trim();
            if (message === '') return;

            displayMessage('user', message); // Affiche le message utilisateur dans le chat
            userInput.value = ''; // Vide la zone de saisie
            sendButton.disabled = true; // Désactive le bouton Envoyer pendant le traitement
            loadingIndicator.style.display = 'block'; // Affiche l'indicateur de chargement

            let historyToSend = [];
            if (currentConversationId === "new_ephemeral") {
                // Pour les conversations éphémères, envoie l'historique complet (y compris le message utilisateur actuel) au backend
                historyToSend = ephemeralChatHistory.map(msg => ({
                    sender: msg.sender,
                    content: msg.content
                }));
            }
            
            try {
                // Utilise fetch pour envoyer une requête POST classique
                const response = await fetch('/chat', { // Remplace /chat_stream par /chat
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        message: message, 
                        conversation_id: currentConversationId,
                        ephemeral_history: historyToSend 
                    })
                });

                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }

                const data = await response.json(); // Attend la réponse JSON complète
                displayMessage('bot', data.response); // Affiche la réponse complète

                // Une fois le message complet affiché, on le sauvegarde dans l'historique éphémère
                if (currentConversationId === "new_ephemeral") {
                    ephemeralChatHistory.push({ sender: 'bot', content: data.response });
                }

            } catch (error) {
                console.error('Erreur lors de l\'envoi du message:', error);
                displayMessage('bot', 'Désolé, une erreur est survenue lors de la communication.');
                if (currentConversationId === "new_ephemeral") {
                    ephemeralChatHistory.push({ sender: 'bot', content: 'Erreur.' });
                }
            } finally {
                sendButton.disabled = false;
                loadingIndicator.style.display = 'none';
            }
        };

        // Permet l'envoi du message avec la touche Entrée
        userInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendButton.click();
            }
        });

        // Initialisation de l'interface utilisateur au chargement de la page
        document.addEventListener('DOMContentLoaded', () => {
            fetchConversations(); // Charge la liste des conversations existantes
            loadConversation("new_ephemeral"); // Active la conversation éphémère par défaut
        });
    </script>
</body>
</html>